package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/saleh-ghazimoradi/MircoEcoMarket/account/dto"
	catalogDTO "github.com/saleh-ghazimoradi/MircoEcoMarket/catalog/dto"
	"github.com/saleh-ghazimoradi/MircoEcoMarket/gateway/graph/model"
	orderDTO "github.com/saleh-ghazimoradi/MircoEcoMarket/order/dto"
)

func (r *accountResolver) Orders(ctx context.Context, obj *model.Account) ([]*model.Order, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	orders, err := r.OrderClient.GetOrdersForAccount(ctx, obj.ID)
	if err != nil {
		log.Printf("Error fetching orders for account %s: %v", obj.ID, err)
		return nil, err
	}

	// No need to fetch catalogs againâ€”use pre-enriched o.Catalogs
	var result []*model.Order
	for _, o := range orders {
		var products []*model.OrderedProduct
		for _, c := range o.Catalogs {
			products = append(products, &model.OrderedProduct{
				ID:          c.Id,
				Name:        c.Name, // From gRPC enrichment
				Description: c.Description,
				Price:       c.Price,
				Quantity:    int32(c.Quantity),
			})
		}
		result = append(result, &model.Order{
			ID:         o.Id,
			AccountID:  o.AccountId,
			CreatedAt:  o.CreatedAt,
			TotalPrice: o.TotalPrice,
			Products:   products,
		})
	}

	return result, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, account model.AccountInput) (*model.Account, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	acc, err := r.AccountClient.CreateAccount(ctx, &dto.Account{
		Name: account.Name,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &model.Account{
		ID:   acc.Id,
		Name: acc.Name,
	}, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, product model.CatalogInput) (*model.Catalog, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	cat, err := r.CatalogClient.CreateCatalog(ctx, &catalogDTO.Catalog{
		Name:        product.Name,
		Description: product.Description,
		Price:       product.Price,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Catalog{
		ID:          cat.Id,
		Name:        cat.Name,
		Description: cat.Description,
		Price:       cat.Price,
	}, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, order model.OrderInput) (*model.Order, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	if order.AccountID == "" {
		return nil, fmt.Errorf("account ID is required")
	}
	if len(order.Products) == 0 {
		return nil, fmt.Errorf("order must contain at least one product")
	}

	// Convert GraphQL products to OrderDTO OrderedCatalogs
	var orderedCatalogs []*orderDTO.OrderedCatalog
	var catalogIDs []string
	for _, p := range order.Products {
		if p.Quantity <= 0 {
			return nil, fmt.Errorf("quantity for product %s must be greater than zero", p.ID)
		}
		orderedCatalogs = append(orderedCatalogs, &orderDTO.OrderedCatalog{
			Id:       p.ID,
			Quantity: uint32(p.Quantity),
		})
		catalogIDs = append(catalogIDs, p.ID)
	}

	// Send CreateOrder gRPC request
	o, err := r.OrderClient.CreateOrder(ctx, &orderDTO.Order{
		AccountId: order.AccountID,
		Catalogs:  orderedCatalogs,
	})
	if err != nil {
		log.Printf("Error creating order: %v", err)
		return nil, err
	}

	// Fetch full catalog info from Catalog service
	catalogs, err := r.CatalogClient.GetCatalogs(ctx, &catalogDTO.CatalogQuery{
		Ids: catalogIDs,
	})
	if err != nil {
		log.Printf("Error fetching catalogs: %v", err)
		return nil, err
	}

	// Map catalog info to GraphQL model
	var products []*model.OrderedProduct
	for _, c := range o.Catalogs {
		for _, cat := range catalogs {
			if cat.Id == c.Id {
				products = append(products, &model.OrderedProduct{
					ID:          c.Id,
					Name:        cat.Name,
					Description: cat.Description,
					Price:       cat.Price,
					Quantity:    int32(c.Quantity),
				})
				break
			}
		}
	}

	return &model.Order{
		ID:         o.Id,
		TotalPrice: o.TotalPrice,
		CreatedAt:  o.CreatedAt,
		Products:   products,
	}, nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, pagination *model.PaginationInput, id *string) ([]*model.Account, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	if id != nil {
		acc, err := r.AccountClient.GetAccountById(ctx, *id)
		if err != nil {
			log.Println(err)
			return nil, err
		}
		return []*model.Account{{
			ID:   acc.Id,
			Name: acc.Name,
		}}, nil
	}

	limit, offset := int32(0), int32(0)
	if pagination != nil {
		limit, offset = pagination.Limit, pagination.Offset
	}

	accs, err := r.AccountClient.GetAccounts(ctx, &dto.AccountQuery{
		Limit:  uint64(limit),
		Offset: uint64(offset),
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	var accounts []*model.Account
	for _, ac := range accs {
		account := &model.Account{
			ID:   ac.Id,
			Name: ac.Name,
		}
		accounts = append(accounts, account)
	}
	return accounts, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, pagination *model.PaginationInput, query *string, id *string) ([]*model.Catalog, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	if r.CatalogClient == nil {
		log.Println("CatalogClient is nil!")
		return nil, fmt.Errorf("internal system error")
	}

	if id != nil {
		cat, err := r.CatalogClient.GetCatalogById(ctx, *id)
		if err != nil {
			log.Println(err)
			return nil, err
		}
		return []*model.Catalog{{
			ID:          cat.Id,
			Name:        cat.Name,
			Description: cat.Description,
			Price:       cat.Price,
		}}, nil
	}

	limit, offset := int32(0), int32(0)
	if pagination != nil {
		limit, offset = pagination.Limit, pagination.Offset
	}

	q := ""
	if query != nil {
		q = *query
	}

	catalogs, err := r.CatalogClient.GetCatalogs(ctx, &catalogDTO.CatalogQuery{
		Limit:  uint64(limit),
		Offset: uint64(offset),
		Query:  q,
		Ids:    nil,
	})

	if err != nil {
		log.Println(err)
		return nil, err
	}

	var catalog []*model.Catalog
	for _, cat := range catalogs {
		catalog = append(catalog, &model.Catalog{
			ID:          cat.Id,
			Name:        cat.Name,
			Description: cat.Description,
			Price:       cat.Price,
		})
	}

	return catalog, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, order model.OrderInput) ([]*model.Order, error) {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Fetch orders for the account
	orders, err := r.OrderClient.GetOrdersForAccount(ctx, order.AccountID)
	if err != nil {
		log.Printf("Error fetching orders for account %s: %v", order.AccountID, err)
		return nil, err
	}

	// Collect catalog IDs
	catalogIdMap := make(map[string]bool)
	for _, o := range orders {
		for _, c := range o.Catalogs {
			catalogIdMap[c.Id] = true
		}
	}
	var catalogIDs []string
	for id := range catalogIdMap {
		catalogIDs = append(catalogIDs, id)
	}

	// Fetch full catalog details
	catalogs, err := r.CatalogClient.GetCatalogs(ctx, &catalogDTO.CatalogQuery{
		Ids: catalogIDs,
	})
	if err != nil {
		log.Printf("Error fetching catalogs for orders: %v", err)
		return nil, err
	}

	// Map orders + products
	var result []*model.Order
	for _, o := range orders {
		var products []*model.OrderedProduct
		for _, c := range o.Catalogs {
			for _, cat := range catalogs {
				if cat.Id == c.Id {
					products = append(products, &model.OrderedProduct{
						ID:          c.Id,
						Name:        cat.Name,
						Description: cat.Description,
						Price:       cat.Price,
						Quantity:    int32(c.Quantity),
					})
					break
				}
			}
		}
		result = append(result, &model.Order{
			ID:         o.Id,
			AccountID:  o.AccountId,
			CreatedAt:  o.CreatedAt,
			TotalPrice: o.TotalPrice,
			Products:   products,
		})
	}

	return result, nil
}

// Account returns AccountResolver implementation.
func (r *Resolver) Account() AccountResolver { return &accountResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type accountResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
