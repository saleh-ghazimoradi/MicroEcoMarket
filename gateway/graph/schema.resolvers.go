package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"log"
	"time"

	"github.com/saleh-ghazimoradi/MircoEcoMarket/account/dto"
	catalogDTO "github.com/saleh-ghazimoradi/MircoEcoMarket/catalog/dto"
	"github.com/saleh-ghazimoradi/MircoEcoMarket/gateway/graph/model"
)

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, account model.AccountInput) (*model.Account, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	acc, err := r.AccountClient.CreateAccount(ctx, &dto.Account{
		Name: account.Name,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &model.Account{
		ID:   acc.Id,
		Name: acc.Name,
	}, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, product model.CatalogInput) (*model.Catalog, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	cat, err := r.CatalogClient.CreateCatalog(ctx, &catalogDTO.Catalog{
		Name:        product.Name,
		Description: product.Description,
		Price:       product.Price,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Catalog{
		ID:          cat.Id,
		Name:        cat.Name,
		Description: cat.Description,
		Price:       cat.Price,
	}, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, order model.OrderInput) (*model.Order, error) {
	//ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	//defer cancel()
	//
	//var products []*model.OrderedProduct
	//for _, product := range order.Products {
	//	if product.Quantity <= 0 {
	//		return nil, errors.New("quantity must be greater than zero")
	//	}
	//	products = append(products, &model.OrderedProduct{
	//		ID:       product.ID,
	//		Quantity: product.Quantity,
	//	})
	//}
	//
	//o, err := r.OrderClient.CreateOrder(ctx, &orderDTO.Order{
	//	AccountId: order.AccountID,
	//})

	return nil, nil

}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, pagination *model.PaginationInput, id *string) ([]*model.Account, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	if id != nil {
		acc, err := r.AccountClient.GetAccountById(ctx, *id)
		if err != nil {
			log.Println(err)
			return nil, err
		}
		return []*model.Account{{
			ID:   acc.Id,
			Name: acc.Name,
		}}, nil
	}

	limit, offset := int32(0), int32(0)
	if pagination != nil {
		limit, offset = pagination.Limit, pagination.Offset
	}

	accs, err := r.AccountClient.GetAccounts(ctx, &dto.AccountQuery{
		Limit:  uint64(limit),
		Offset: uint64(offset),
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	var accounts []*model.Account
	for _, ac := range accs {
		account := &model.Account{
			ID:   ac.Id,
			Name: ac.Name,
		}
		accounts = append(accounts, account)
	}
	return accounts, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, pagination *model.PaginationInput, query *string, id *string) ([]*model.Catalog, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	if id != nil {
		cat, err := r.CatalogClient.GetCatalogById(ctx, *id)
		if err != nil {
			log.Println(err)
			return nil, err
		}
		return []*model.Catalog{{
			ID:          cat.Id,
			Name:        cat.Name,
			Description: cat.Description,
			Price:       cat.Price,
		}}, nil
	}

	limit, offset := int32(0), int32(0)
	if pagination != nil {
		limit, offset = pagination.Limit, pagination.Offset
	}

	q := ""
	if query != nil {
		q = *query
	}

	catalogs, err := r.CatalogClient.GetCatalogs(ctx, &catalogDTO.CatalogQuery{
		Limit:  uint64(limit),
		Offset: uint64(offset),
		Query:  q,
		Ids:    nil,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}

	var catalog []*model.Catalog
	for _, cat := range catalogs {
		catalog = append(catalog, &model.Catalog{
			ID:          cat.Id,
			Name:        cat.Name,
			Description: cat.Description,
			Price:       cat.Price,
		})
	}
	return catalog, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, order model.OrderInput) ([]*model.Order, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	orders, err := r.OrderClient.GetOrdersForAccount(ctx, order.AccountID)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	var ords []*model.Order
	for _, ord := range orders {
		var catalogs []*model.OrderedProduct
		for _, cat := range ord.Catalogs {
			catalogs = append(catalogs, &model.OrderedProduct{
				ID:          cat.Id,
				Name:        cat.Name,
				Description: cat.Description,
				Price:       cat.Price,
				Quantity:    int32(cat.Quantity),
			})
		}
		ords = append(ords, &model.Order{
			ID:         ord.Id,
			CreatedAt:  ord.CreatedAt,
			TotalPrice: ord.TotalPrice,
			Products:   catalogs,
		})
	}
	return ords, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
